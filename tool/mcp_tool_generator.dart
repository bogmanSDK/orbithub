import 'dart:async';

import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/dart/ast/visitor.dart';
import 'package:build/build.dart';
import 'package:source_gen/source_gen.dart';
import 'package:glob/glob.dart';

/// Builder that generates MCP tool registry, executor, and schema
/// 
/// This builder automatically scans all Dart files in lib/ directory
/// and generates three complete files:
/// - lib/mcp/generated/mcp_tool_registry.g.dart
/// - lib/mcp/generated/mcp_tool_executor.g.dart
/// - lib/mcp/generated/mcp_schema_generator.g.dart
class McpToolBuilder implements Builder {
  const McpToolBuilder();

  @override
  Map<String, List<String>> get buildExtensions => {
        r'$lib$': [
          'mcp/generated/mcp_tool_registry.g.dart'
        ]
      };

  @override
  Future<void> build(BuildStep buildStep) async {
    // Only process once for $lib$ input
    if (buildStep.inputId.path != 'lib') {
      return;
    }

    // Find all Dart files in lib/
    final dartFiles = await buildStep.findAssets(Glob('lib/**/*.dart')).toList();
    
    final allTools = <ToolDefinition>[];

    // Parse each file and extract tools
    for (final fileId in dartFiles) {
      try {
        final unit = await buildStep.resolver.compilationUnitFor(fileId);
        if (unit != null) {
          final extractor = _ToolExtractor(fileId.path);
          unit.visitChildren(extractor);
          allTools.addAll(extractor.tools);
        }
      } catch (e) {
        // Skip files that can't be parsed
        print('Warning: Could not parse ${fileId.path}: $e');
      }
    }

    // Generate registry file (primary output)
    final registryId = AssetId(buildStep.inputId.package, 'lib/mcp/generated/mcp_tool_registry.g.dart');
    await buildStep.writeAsString(registryId, _generateRegistryFile(allTools));
    
    // Generate executor file (write directly, not through build extensions)
    final executorId = AssetId(buildStep.inputId.package, 'lib/mcp/generated/mcp_tool_executor.g.dart');
    await buildStep.writeAsString(executorId, _generateExecutorFile(allTools));
    
    // Generate schema file (write directly)
    final schemaId = AssetId(buildStep.inputId.package, 'lib/mcp/generated/mcp_schema_generator.g.dart');
    await buildStep.writeAsString(schemaId, _generateSchemaFile(allTools));
  }

  String _generateRegistryFile(List<ToolDefinition> tools) {
    final buffer = StringBuffer();
    
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// This file is generated by build_runner');
    buffer.writeln('');
    buffer.writeln("import 'package:orbithub/mcp/tool_registry.dart';");
    buffer.writeln("import 'package:orbithub/mcp/tool_definitions.dart';");
    buffer.writeln('');
    buffer.writeln('void _registerAllTools() {');
    
    for (final tool in tools) {
      buffer.writeln('  McpToolRegistry.registerTool(McpToolDefinition(');
      buffer.writeln("    name: '${_escapeString(tool.name)}',");
      buffer.writeln("    description: '${_escapeString(tool.description)}',");
      buffer.writeln("    integration: '${_escapeString(tool.integration)}',");
      buffer.writeln("    category: '${_escapeString(tool.category)}',");
      buffer.writeln("    className: '${tool.className}',");
      buffer.writeln("    methodName: '${tool.methodName}',");
      buffer.writeln("    returnType: '${tool.returnType}',");
      buffer.writeln('    parameters: [');
      
      for (final param in tool.parameters) {
        buffer.writeln('      McpParameterDefinition(');
        buffer.writeln("        name: '${_escapeString(param.name)}',");
        buffer.writeln("        description: '${_escapeString(param.description)}',");
        buffer.writeln('        required: ${param.required},');
        buffer.writeln("        example: '${_escapeString(param.example)}',");
        buffer.writeln("        type: '${_escapeString(param.type)}',");
        buffer.writeln("        dartType: '${param.dartType}',");
        buffer.writeln('        parameterIndex: ${param.parameterIndex},');
        buffer.writeln('      ),');
      }
      
      buffer.writeln('    ],');
      buffer.writeln('  ));');
      buffer.writeln('');
    }
    
    buffer.writeln('}');
    return buffer.toString();
  }

  String _generateExecutorFile(List<ToolDefinition> tools) {
    final buffer = StringBuffer();
    
    // Collect unique imports
    final imports = <String>{};
    for (final tool in tools) {
      if (tool.integration == 'jira') {
        imports.add("import 'package:orbithub/core/jira/jira_client.dart';");
      } else if (tool.integration == 'confluence') {
        imports.add("import 'package:orbithub/core/confluence/confluence_client.dart';");
      }
    }
    
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// This file is generated by build_runner');
    buffer.writeln('');
    for (final import in imports) {
      buffer.writeln(import);
    }
    buffer.writeln('');
    buffer.writeln('Future<dynamic> executeTool(');
    buffer.writeln('  String toolName,');
    buffer.writeln('  Map<String, dynamic> arguments,');
    buffer.writeln('  Map<String, dynamic> clientInstances,');
    buffer.writeln(') async {');
    buffer.writeln('  switch (toolName) {');
    
    for (final tool in tools) {
      buffer.writeln("    case '${_escapeString(tool.name)}':");
      buffer.writeln('      {');
      
      // Get client instance
      buffer.writeln("        final client = clientInstances['${tool.integration}'] as ${tool.className};");
      buffer.writeln('        return await client.${tool.methodName}(');
      
      // Generate method call with parameters
      final positionalParams = tool.parameters.where((p) => p.isPositional).toList();
      final namedParams = tool.parameters.where((p) => !p.isPositional).toList();
      
      // Positional parameters
      for (int i = 0; i < positionalParams.length; i++) {
        final param = positionalParams[i];
        final comma = i < positionalParams.length - 1 || namedParams.isNotEmpty ? ',' : '';
        buffer.writeln('          ${_generateParameterCast(param)}${comma}');
      }
      
      // Named parameters
      if (namedParams.isNotEmpty) {
        for (int i = 0; i < namedParams.length; i++) {
          final param = namedParams[i];
          final comma = i < namedParams.length - 1 ? ',' : '';
          buffer.writeln('          ${param.name}: ${_generateParameterCast(param)}${comma}');
        }
      }
      
      buffer.writeln('        );');
      buffer.writeln('      }');
    }
    
    buffer.writeln('    default:');
    buffer.writeln("      throw ArgumentError('Unknown tool: \$toolName');");
    buffer.writeln('  }');
    buffer.writeln('}');
    
    return buffer.toString();
  }

  String _generateSchemaFile(List<ToolDefinition> tools) {
    final buffer = StringBuffer();
    
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// This file is generated by build_runner');
    buffer.writeln('');
    buffer.writeln('Map<String, dynamic> generateMcpSchema() {');
    buffer.writeln('  return {');
    buffer.writeln("    'tools': [");
    
    for (final tool in tools) {
      buffer.writeln('      {');
      buffer.writeln("        'name': '${_escapeString(tool.name)}',");
      buffer.writeln("        'description': '${_escapeString(tool.description)}',");
      buffer.writeln("        'inputSchema': {");
      buffer.writeln("          'type': 'object',");
      buffer.writeln("          'properties': {");
      
      for (final param in tool.parameters) {
        buffer.writeln("            '${_escapeString(param.name)}': {");
        buffer.writeln("              'type': '${_getMcpType(param.dartType)}',");
        buffer.writeln("              'description': '${_escapeString(param.description)}',");
        if (param.example.isNotEmpty) {
          buffer.writeln("              'example': '${_escapeString(param.example)}',");
        }
        buffer.writeln('            },');
      }
      
      buffer.writeln("          },");
      final required = tool.parameters.where((p) => p.required).map((p) => "'${p.name}'").join(', ');
      buffer.writeln("          'required': [$required],");
      buffer.writeln('        },');
      buffer.writeln('      },');
    }
    
    buffer.writeln('    ],');
    buffer.writeln('  };');
    buffer.writeln('}');
    
    return buffer.toString();
  }

  String _escapeString(String str) {
    return str.replaceAll("'", "\\'").replaceAll('\n', '\\n').replaceAll('\r', '\\r');
  }

  String _generateParameterCast(ParameterDefinition param) {
    final type = param.dartType;
    final nullable = type.endsWith('?');
    final baseType = nullable ? type.substring(0, type.length - 1) : type;
    
    if (nullable) {
      return "arguments['${param.name}'] as $baseType?";
    } else {
      return "arguments['${param.name}'] as $baseType";
    }
  }

  String _getMcpType(String dartType) {
    final cleanType = dartType.replaceAll('?', '').trim();
    if (cleanType.startsWith('List<')) return 'array';
    if (cleanType.startsWith('Map<')) return 'object';
    if (cleanType == 'String') return 'string';
    if (cleanType == 'int' || cleanType == 'double' || cleanType == 'num') return 'number';
    if (cleanType == 'bool') return 'boolean';
    return 'object';
  }
}

// Helper classes
class ToolDefinition {
  final String name;
  final String description;
  final String integration;
  final String category;
  final String className;
  final String methodName;
  final String returnType;
  final List<ParameterDefinition> parameters;

  ToolDefinition({
    required this.name,
    required this.description,
    required this.integration,
    required this.category,
    required this.className,
    required this.methodName,
    required this.returnType,
    required this.parameters,
  });
}

class ParameterDefinition {
  final String name;
  final String description;
  final bool required;
  final String example;
  final String type;
  final String dartType;
  final int parameterIndex;
  final bool isPositional;

  ParameterDefinition({
    required this.name,
    required this.description,
    required this.required,
    required this.example,
    required this.type,
    required this.dartType,
    required this.parameterIndex,
    required this.isPositional,
  });
}

// AST Visitor to extract tools
class _ToolExtractor extends RecursiveAstVisitor<void> {
  final List<ToolDefinition> tools = [];
  final String filePath;

  _ToolExtractor(this.filePath);

  @override
  void visitMethodDeclaration(MethodDeclaration node) {
    // Check for @McpTool annotation
    McpToolAnnotation? toolAnnotation;
    for (final annotation in node.metadata) {
      final annotationName = annotation.name?.name;
      if (annotationName == 'McpTool') {
        toolAnnotation = _extractMcpToolAnnotation(annotation);
        break;
      }
    }

    if (toolAnnotation == null) {
      super.visitMethodDeclaration(node);
      return;
    }

    // Extract parameters
    final parameters = <ParameterDefinition>[];
    int paramIndex = 0;
    
    final paramList = node.parameters?.parameters ?? [];
    for (final param in paramList) {
      if (param is SimpleFormalParameter) {
        final paramAnnotation = _extractMcpParamAnnotation(param.metadata);
        final type = param.type?.toString() ?? 'dynamic';
        final isOptional = param.isOptional || type.endsWith('?');
        
        parameters.add(ParameterDefinition(
          name: paramAnnotation?.name ?? param.name?.lexeme ?? 'param$paramIndex',
          description: paramAnnotation?.description ?? '',
          required: paramAnnotation?.required ?? !isOptional,
          example: paramAnnotation?.example ?? '',
          type: paramAnnotation?.type ?? '',
          dartType: type,
          parameterIndex: paramIndex,
          isPositional: !param.isNamed,
        ));
        paramIndex++;
      } else if (param is DefaultFormalParameter) {
        final simpleParam = param.parameter;
        if (simpleParam is SimpleFormalParameter) {
          final paramAnnotation = _extractMcpParamAnnotation(simpleParam.metadata);
          final type = simpleParam.type?.toString() ?? 'dynamic';
          
          parameters.add(ParameterDefinition(
            name: paramAnnotation?.name ?? simpleParam.name?.lexeme ?? 'param$paramIndex',
            description: paramAnnotation?.description ?? '',
            required: paramAnnotation?.required ?? false,
            example: paramAnnotation?.example ?? '',
            type: paramAnnotation?.type ?? '',
            dartType: type,
            parameterIndex: paramIndex,
            isPositional: !simpleParam.isNamed,
          ));
          paramIndex++;
        }
      }
    }

    // Extract class name from parent
    String className = 'Unknown';
    final parent = node.parent;
    if (parent is ClassDeclaration) {
      className = parent.name.lexeme;
    }

    // Extract return type
    final returnType = node.returnType?.toString() ?? 'void';

    tools.add(ToolDefinition(
      name: toolAnnotation.name,
      description: toolAnnotation.description,
      integration: toolAnnotation.integration,
      category: toolAnnotation.category,
      className: className,
      methodName: node.name.lexeme,
      returnType: returnType,
      parameters: parameters,
    ));

    super.visitMethodDeclaration(node);
  }

  McpToolAnnotation? _extractMcpToolAnnotation(Annotation annotation) {
    try {
      // Try to extract from AST directly
      if (annotation.arguments is ArgumentList) {
        final args = annotation.arguments as ArgumentList;
        String name = '';
        String description = '';
        String integration = '';
        String category = '';
        
        for (final arg in args.arguments) {
          if (arg is NamedExpression) {
            final label = arg.name.label.name;
            if (arg.expression is StringLiteral) {
              final value = (arg.expression as StringLiteral).stringValue ?? '';
              switch (label) {
                case 'name':
                  name = value;
                  break;
                case 'description':
                  description = value;
                  break;
                case 'integration':
                  integration = value;
                  break;
                case 'category':
                  category = value;
                  break;
              }
            }
          }
        }
        
        if (name.isNotEmpty && description.isNotEmpty && integration.isNotEmpty) {
          return McpToolAnnotation(
            name: name,
            description: description,
            integration: integration,
            category: category,
          );
        }
      }
    } catch (e) {
      // Fall through
    }
    return null;
  }

  McpParamAnnotation? _extractMcpParamAnnotation(NodeList<Annotation> metadata) {
    for (final annotation in metadata) {
      final annotationName = annotation.name?.name;
      if (annotationName == 'McpParam') {
        try {
          if (annotation.arguments is ArgumentList) {
            final args = annotation.arguments as ArgumentList;
            String name = '';
            String description = '';
            bool required = true;
            String example = '';
            String type = '';
            
            for (final arg in args.arguments) {
              if (arg is NamedExpression) {
                final label = arg.name.label.name;
                if (arg.expression is StringLiteral) {
                  final value = (arg.expression as StringLiteral).stringValue ?? '';
                  switch (label) {
                    case 'name':
                      name = value;
                      break;
                    case 'description':
                      description = value;
                      break;
                    case 'example':
                      example = value;
                      break;
                    case 'type':
                      type = value;
                      break;
                  }
                } else if (arg.expression is BooleanLiteral) {
                  if (label == 'required') {
                    required = (arg.expression as BooleanLiteral).value;
                  }
                }
              }
            }
            
            if (name.isNotEmpty) {
              return McpParamAnnotation(
                name: name,
                description: description,
                required: required,
                example: example,
                type: type,
              );
            }
          }
        } catch (e) {
          // Fall through
        }
      }
    }
    return null;
  }
}

class McpToolAnnotation {
  final String name;
  final String description;
  final String integration;
  final String category;

  McpToolAnnotation({
    required this.name,
    required this.description,
    required this.integration,
    required this.category,
  });
}

class McpParamAnnotation {
  final String name;
  final String description;
  final bool required;
  final String example;
  final String type;

  McpParamAnnotation({
    required this.name,
    required this.description,
    required this.required,
    required this.example,
    required this.type,
  });
}

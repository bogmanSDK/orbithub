#!/usr/bin/env dart

/// Standalone script to generate MCP tool registry, executor, and schema files
/// Run with: dart run tool/generate_mcp_files.dart

import 'dart:io';
import 'package:analyzer/dart/analysis/features.dart';
import 'package:analyzer/dart/analysis/utilities.dart';
import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/dart/ast/visitor.dart';

void main() async {
  print('Scanning for @McpTool annotations...');
  
  final allTools = <ToolDefinition>[];
  final libDir = Directory('lib');
  
  await for (final entity in libDir.list(recursive: true)) {
    if (entity is File && entity.path.endsWith('.dart')) {
      try {
        final content = await entity.readAsString();
        final parseResult = parseString(
          content: content,
          featureSet: FeatureSet.latestLanguageVersion(),
          path: entity.path,
        );
        
        final extractor = _ToolExtractor(entity.path);
        parseResult.unit.visitChildren(extractor);
        allTools.addAll(extractor.tools);
      } catch (e) {
        // Skip files that can't be parsed
        print('Warning: Could not parse ${entity.path}: $e');
      }
    }
  }
  
  print('Found ${allTools.length} tools');
  
  // Generate files
  final outputDir = Directory('lib/mcp/generated');
  await outputDir.create(recursive: true);
  
  await File('lib/mcp/generated/mcp_tool_registry.g.dart')
      .writeAsString(_generateRegistryFile(allTools));
  print('Generated mcp_tool_registry.g.dart');
  
  await File('lib/mcp/generated/mcp_tool_executor.g.dart')
      .writeAsString(_generateExecutorFile(allTools));
  print('Generated mcp_tool_executor.g.dart');
  
  await File('lib/mcp/generated/mcp_schema_generator.g.dart')
      .writeAsString(_generateSchemaFile(allTools));
  print('Generated mcp_schema_generator.g.dart');
  
  print('Done! Generated ${allTools.length} tools');
}

String _generateRegistryFile(List<ToolDefinition> tools) {
  final buffer = StringBuffer();
  
  buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
  buffer.writeln('// This file is generated by tool/generate_mcp_files.dart');
  buffer.writeln('');
  buffer.writeln("import 'package:orbithub/mcp/tool_registry.dart';");
  buffer.writeln("import 'package:orbithub/mcp/tool_definitions.dart';");
  buffer.writeln('');
  buffer.writeln('void registerAllTools() {');
  
  for (final tool in tools) {
    buffer.writeln('  McpToolRegistry.registerTool(McpToolDefinition(');
    buffer.writeln("    name: '${_escapeString(tool.name)}',");
    buffer.writeln("    description: '${_escapeString(tool.description)}',");
    buffer.writeln("    integration: '${_escapeString(tool.integration)}',");
    buffer.writeln("    category: '${_escapeString(tool.category)}',");
    buffer.writeln("    className: '${tool.className}',");
    buffer.writeln("    methodName: '${tool.methodName}',");
    buffer.writeln("    returnType: '${tool.returnType}',");
    buffer.writeln('    parameters: [');
    
    for (final param in tool.parameters) {
      buffer.writeln('      McpParameterDefinition(');
      buffer.writeln("        name: '${_escapeString(param.name)}',");
      buffer.writeln("        description: '${_escapeString(param.description)}',");
      buffer.writeln('        required: ${param.required},');
      buffer.writeln("        example: '${_escapeString(param.example)}',");
      buffer.writeln("        type: '${_escapeString(param.type)}',");
      buffer.writeln("        dartType: '${param.dartType}',");
      buffer.writeln('        parameterIndex: ${param.parameterIndex},');
      buffer.writeln('      ),');
    }
    
    buffer.writeln('    ],');
    buffer.writeln('  ));');
    buffer.writeln('');
  }
  
  buffer.writeln('}');
  return buffer.toString();
}

String _generateExecutorFile(List<ToolDefinition> tools) {
  final buffer = StringBuffer();
  
  // Collect unique imports
  final imports = <String>{};
  for (final tool in tools) {
    if (tool.integration == 'jira') {
      imports.add("import 'package:orbithub/core/jira/jira_client.dart';");
    } else if (tool.integration == 'confluence') {
      imports.add("import 'package:orbithub/core/confluence/confluence_client.dart';");
    }
  }
  
  buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
  buffer.writeln('// This file is generated by tool/generate_mcp_files.dart');
  buffer.writeln('');
  for (final import in imports) {
    buffer.writeln(import);
  }
  buffer.writeln('');
  buffer.writeln('Future<dynamic> executeTool(');
  buffer.writeln('  String toolName,');
  buffer.writeln('  Map<String, dynamic> arguments,');
  buffer.writeln('  Map<String, dynamic> clientInstances,');
  buffer.writeln(') async {');
  buffer.writeln('  switch (toolName) {');
  
  for (final tool in tools) {
    buffer.writeln("    case '${_escapeString(tool.name)}':");
    buffer.writeln('      {');
    
    // Get client instance
    buffer.writeln("        final client = clientInstances['${tool.integration}'] as ${tool.className};");
    buffer.writeln('        return await client.${tool.methodName}(');
    
    // Generate method call with parameters
    final positionalParams = tool.parameters.where((p) => p.isPositional).toList();
    final namedParams = tool.parameters.where((p) => !p.isPositional).toList();
    
    // Positional parameters
    for (int i = 0; i < positionalParams.length; i++) {
      final param = positionalParams[i];
      buffer.write('          ${_generateParameterCast(param)}');
      if (i < positionalParams.length - 1 || namedParams.isNotEmpty) {
        buffer.write(',');
      }
      buffer.writeln();
    }
    
    // Named parameters
    for (int i = 0; i < namedParams.length; i++) {
      final param = namedParams[i];
      buffer.write("          ${param.actualParamName}: ${_generateParameterCast(param)}");
      if (i < namedParams.length - 1) {
        buffer.write(',');
      }
      buffer.writeln();
    }
    
    buffer.writeln('        );');
    buffer.writeln('      }');
  }
  
  buffer.writeln("    default:");
  buffer.writeln("      throw ArgumentError('Unknown tool: \$toolName');");
  buffer.writeln('  }');
  buffer.writeln('}');
  
  return buffer.toString();
}

String _generateSchemaFile(List<ToolDefinition> tools) {
  final buffer = StringBuffer();
  
  buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
  buffer.writeln('// This file is generated by tool/generate_mcp_files.dart');
  buffer.writeln('');
  buffer.writeln('Map<String, dynamic> generateMcpSchema() {');
  buffer.writeln('  return {');
  buffer.writeln("    'tools': [");
  
  for (final tool in tools) {
    buffer.writeln('      {');
    buffer.writeln("        'name': '${_escapeString(tool.name)}',");
    buffer.writeln("        'description': '${_escapeString(tool.description)}',");
    buffer.writeln("        'inputSchema': {");
    buffer.writeln("          'type': 'object',");
    buffer.writeln("          'properties': {");
    
    for (final param in tool.parameters) {
      buffer.writeln("            '${param.name}': {");
      buffer.writeln("              'type': '${_getMcpType(param.dartType)}',");
      buffer.writeln("              'description': '${_escapeString(param.description)}',");
      if (param.example.isNotEmpty) {
        buffer.writeln("              'example': '${_escapeString(param.example)}',");
      }
      buffer.writeln('            },');
    }
    
    buffer.writeln("          },");
    final required = tool.parameters.where((p) => p.required).map((p) => "'${p.name}'").join(', ');
    buffer.writeln("          'required': [$required],");
    buffer.writeln('        },');
    buffer.writeln('      },');
  }
  
  buffer.writeln('    ],');
  buffer.writeln('  };');
  buffer.writeln('}');
  
  return buffer.toString();
}

String _escapeString(String str) {
  return str.replaceAll("'", "\\'").replaceAll('\n', '\\n').replaceAll('\r', '\\r');
}

String _generateParameterCast(ParameterDefinition param) {
  final type = param.dartType;
  final nullable = type.endsWith('?');
  final baseType = nullable ? type.substring(0, type.length - 1) : type;
  
  if (nullable) {
    return "arguments['${param.name}'] as $baseType?";
  } else {
    return "arguments['${param.name}'] as $baseType";
  }
}

String _getMcpType(String dartType) {
  final cleanType = dartType.replaceAll('?', '').trim();
  if (cleanType.startsWith('List<')) return 'array';
  if (cleanType.startsWith('Map<')) return 'object';
  if (cleanType == 'String') return 'string';
  if (cleanType == 'int' || cleanType == 'double' || cleanType == 'num') return 'number';
  if (cleanType == 'bool') return 'boolean';
  return 'object';
}

// Helper classes
class ToolDefinition {
  final String name;
  final String description;
  final String integration;
  final String category;
  final String className;
  final String methodName;
  final String returnType;
  final List<ParameterDefinition> parameters;

  ToolDefinition({
    required this.name,
    required this.description,
    required this.integration,
    required this.category,
    required this.className,
    required this.methodName,
    required this.returnType,
    required this.parameters,
  });
}

class ParameterDefinition {
  final String name;
  final String description;
  final bool required;
  final String example;
  final String type;
  final String dartType;
  final int parameterIndex;
  final bool isPositional;
  final String actualParamName;

  ParameterDefinition({
    required this.name,
    required this.description,
    required this.required,
    required this.example,
    required this.type,
    required this.dartType,
    required this.parameterIndex,
    required this.isPositional,
    required this.actualParamName,
  });
}

// AST Visitor to extract tools
class _ToolExtractor extends RecursiveAstVisitor<void> {
  final List<ToolDefinition> tools = [];
  final String filePath;

  _ToolExtractor(this.filePath);

  @override
  void visitMethodDeclaration(MethodDeclaration node) {
    // Check for @McpTool annotation
    McpToolAnnotation? toolAnnotation;
    for (final annotation in node.metadata) {
      final annotationName = annotation.name?.name;
      if (annotationName == 'McpTool') {
        toolAnnotation = _extractMcpToolAnnotation(annotation);
        break;
      }
    }

    if (toolAnnotation == null) {
      super.visitMethodDeclaration(node);
      return;
    }

    // Extract class name from file path
    final className = _extractClassName(node);
    final methodName = node.name.lexeme;
    final returnType = node.returnType?.toSource() ?? 'void';

    // Extract parameters
    final parameters = <ParameterDefinition>[];
    int paramIndex = 0;
    
    final paramList = node.parameters?.parameters ?? [];
    for (final param in paramList) {
      if (param is SimpleFormalParameter || param is DefaultFormalParameter) {
        final paramAnnotation = _extractMcpParamAnnotation(param.metadata);
        
        if (paramAnnotation != null) {
          String dartType;
          bool isPositional;
          String actualParamName;
          
          if (param is SimpleFormalParameter) {
            dartType = param.type?.toSource() ?? 'dynamic';
            isPositional = param.isPositional;
            actualParamName = param.name?.lexeme ?? '';
          } else {
            final defaultParam = param as DefaultFormalParameter;
            dartType = defaultParam.parameter.declaredElement?.type.toString() ?? 'dynamic';
            isPositional = defaultParam.isPositional;
            actualParamName = defaultParam.parameter.name?.lexeme ?? '';
          }
          
          parameters.add(ParameterDefinition(
            name: paramAnnotation.name,
            description: paramAnnotation.description,
            required: paramAnnotation.required,
            example: paramAnnotation.example,
            type: paramAnnotation.type,
            dartType: dartType,
            parameterIndex: paramIndex,
            isPositional: isPositional,
            actualParamName: actualParamName,
          ));
        }
      }
      paramIndex++;
    }

    tools.add(ToolDefinition(
      name: toolAnnotation.name,
      description: toolAnnotation.description,
      integration: toolAnnotation.integration,
      category: toolAnnotation.category,
      className: className,
      methodName: methodName,
      returnType: returnType,
      parameters: parameters,
    ));

    super.visitMethodDeclaration(node);
  }

  String _extractClassName(MethodDeclaration node) {
    AstNode? current = node.parent;
    while (current != null) {
      if (current is ClassDeclaration) {
        return current.name.lexeme;
      }
      current = current.parent;
    }
    return 'Unknown';
  }

  McpToolAnnotation? _extractMcpToolAnnotation(Annotation annotation) {
    try {
      if (annotation.arguments is ArgumentList) {
        final args = annotation.arguments as ArgumentList;
        String name = '';
        String description = '';
        String integration = '';
        String category = '';
        
        for (final arg in args.arguments) {
          if (arg is NamedExpression) {
            final label = arg.name.label.name;
            if (arg.expression is StringLiteral) {
              final value = (arg.expression as StringLiteral).stringValue ?? '';
              switch (label) {
                case 'name':
                  name = value;
                  break;
                case 'description':
                  description = value;
                  break;
                case 'integration':
                  integration = value;
                  break;
                case 'category':
                  category = value;
                  break;
              }
            }
          }
        }
        
        if (name.isNotEmpty && description.isNotEmpty && integration.isNotEmpty) {
          return McpToolAnnotation(
            name: name,
            description: description,
            integration: integration,
            category: category,
          );
        }
      }
    } catch (e) {
      // Fall through
    }
    return null;
  }

  McpParamAnnotation? _extractMcpParamAnnotation(NodeList<Annotation> metadata) {
    for (final annotation in metadata) {
      final annotationName = annotation.name?.name;
      if (annotationName == 'McpParam') {
        try {
          if (annotation.arguments is ArgumentList) {
            final args = annotation.arguments as ArgumentList;
            String name = '';
            String description = '';
            bool required = true;
            String example = '';
            String type = '';
            
            for (final arg in args.arguments) {
              if (arg is NamedExpression) {
                final label = arg.name.label.name;
                if (arg.expression is StringLiteral) {
                  final value = (arg.expression as StringLiteral).stringValue ?? '';
                  switch (label) {
                    case 'name':
                      name = value;
                      break;
                    case 'description':
                      description = value;
                      break;
                    case 'example':
                      example = value;
                      break;
                    case 'type':
                      type = value;
                      break;
                  }
                } else if (arg.expression is BooleanLiteral) {
                  if (label == 'required') {
                    required = (arg.expression as BooleanLiteral).value;
                  }
                }
              }
            }
            
            if (name.isNotEmpty) {
              return McpParamAnnotation(
                name: name,
                description: description,
                required: required,
                example: example,
                type: type,
              );
            }
          }
        } catch (e) {
          // Fall through
        }
      }
    }
    return null;
  }
}

class McpToolAnnotation {
  final String name;
  final String description;
  final String integration;
  final String category;

  McpToolAnnotation({
    required this.name,
    required this.description,
    required this.integration,
    required this.category,
  });
}

class McpParamAnnotation {
  final String name;
  final String description;
  final bool required;
  final String example;
  final String type;

  McpParamAnnotation({
    required this.name,
    required this.description,
    required this.required,
    required this.example,
    required this.type,
  });
}

